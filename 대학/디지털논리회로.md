# 디지털 논리회로

### 디지털논리회로 1강 주요용어
* 디지털 시스템: 입력과 출력이 디지털 데이터인 시스템

* 디지털 논리회로: 2진 디지털 논리를 논리게이트로 구현한 것

* 집적회로: 디지털 게이트의 기능을 수행하는 전자소자를 포함한 실리콘 반도체 크리스털로서, 칩(chip)이라 함

* 진수변환: 10진수와 r진수 상호 간의 변환 방법

* 보수: 보수는 r의 보수와 (r-1)의 보수가 있다

* 디지털 코드: 데이터를 표현하기 위해 비트를 필요한 수만큼 묶어 각 묶음에 유일한 의미를 부여하는 코드

### 아날로그와 디지털
* 아날로그 방식: 데이터를 연속적인 값으로 표현
* 디지털 방식: 연속적인 값을 근사하여 이산적인 값으로 표현

* 디지털 시스템의 장점
1. 편리성: 데이터가 숫자로 입,출력
2. 융통성: 실행순서의 조정이 가능
3. 단순성: 시스템 설계가 단순
4. 안정성: 0과 1로 유지되므로 높은 안정성
5. 견고성: 잡음 등에 강함
6. 정확성: 논리적인 처리로 정확한 결과 도출

### 디지털 시스템의 설계
1. 회로설계 단계: 능동소자와 수동소자를 연결시키는 단계
2. 논리설계 단계: 논리회로를 만들기 위해 논리소자들을 연결시키는 단계
3. 시스템 설계: 논리회로들을 연결하여 프로세서, 입출력 제어장치 등을 설계하는 단계
4. 실제적 설계: 시스템 설계단계의 부품들을 PCB나 와이어 랩 기판에 배치시키는 단계

### 디지털 논리회로
- 2진 디지털 논리를 논리게이트로 구현한 것
- 디지털 시스템을 구현하는 기본 요소
- 디지털 시스템의 논리설계 단계에서 설계됨

### 디지털 논리회로는 저장요소의 유무에 따라 
- 조합논리회로: 저장요소가 없음(예: 가산기, 디코더 등)
- 순서논리회로: 저장요소가 있음(예: 레지스터, 카운터 등)

### 전자식 데이터 처리 시스템 (EDPS)

### 컴퓨터 하드웨어 구성
1. 입력장치: 외부로부터 데이터를 입력
2. 기억장치: 데이터를 기억하고 저장
3. 연산장치: 데이터에 대한 산술, 논리연산을 수행
4. 제어장치: 데이터 처리를 위한 구성요소들을 제어
5. 출력장치: 처리된 결과를 외부로 출력

### 집적회로 개요
- 디지털회로는 집적회로로 구성
- 집적회로(IC)
- 디지털 게이트의 기능을 수행하는 전자소자를 포함한 작은 실리콘 반도체 크리스털
- 칩(chip)이라고 함
- 칩 내부에 있는 여러 가지 게이트들은 회로의 목적에 부합되도록 상호 연결

### 집적회로의 집적도
- 집적도:단위 실리콘 칩에 집저할 수 있는 게이트의 수
- 소규모 집적(SSI소자): 몇 개의 독립된 게이트를 내장
- 중규모 집적(MSI소자): 대략 10~100여 개의 게이트를 내장(디코더, 레지스터)
- 대규모 집적(LSI소자): 수백~수천 개의 게이트를 내장(프로세서, 기억장치 칩)
- 초대규모 집적(VLS소자): 수천 개 이상의 게이트를 내장(마이크로컴퓨터 칩)

### 양논리와 음논리
- 게이트의 입력과 출력에 대한 2진신호는 두 값 중에 한 값을 갖는다.
- 두 논리값(0,1)에 대한 두 신호값(H,L)을 할당하는 방법
#### 양논리 시스템
- 높은 값 H 를 논리값 1로 하고, 낮은 값 L 를 0으로 하는 시스템
#### 음논리 시스템
- 낮은 값 L 을 논리값 1로 하고,
높은 값 H를 0으로 하는 시스템

### 진법
- 수를 숫자로 나타내는 방법
- 숫자의 위치에 따라 가중치 부여
- 가중치는 기수의 승수(거듭제곱)를 이용
- 기수는 2 이상의 양의 정수
- r진법도 알아두기

### 진수 변환
1. r진수의 10진수 변환
2. 10진수의 r진수 변환(정수부분은 나눗셈, 소수점 아랫부분은 곱셉으로 구함)**p.31 참고**
3. 2진수의 2의 n승 진수 상호 변환 **p.33 참고**
4. 기타변환
#### 산술연산
- p35참고 
- 강의 1강 50분 참고
### 보수
- p38참고 
- 강의 1강 52분 참고

### 10진수를 나타내는 2진 코드
- BCD 8421 코드: 2진화 10진코드의 형식으로 10진수 한 자리를 2진수 4비트로 표시한 것
### 영숫자 코드

# 디지털 논리회로 2강

### 논리연산,논리게이트
- AND: **두 명제가 모두 참이어야 참값을 돌려준다.** C언어의 영향을 받은 프로그래밍 언어에서는 일반적으로 &를 논리곱 연산자로 사용하며, 불 대수에서는 AND는 곱셈과 동치이다. 불 곱(Boolean Multiplication) 혹은 논리곱이라 부른다. 아래의 연산결과를 보면 왜 곱셈과 동치인지 쉽게 알 수 있을 것이다. AB 또는 A·B로 표시한다.
- OR: **두 명제 중 어느 한 명제만 참이어도 참값을 돌려준다.** C언어의 영향을 받은 프로그래밍 언어에서는 일반적으로 |를 논리합 연산자로 사용한다. 불 대수에서는 OR는 덧셈과 동치여서, 논리합(Boolean Addition)으로 부른다. 아래에서 보듯 1 + 1 = 1 임을 주의해야 한다. A+B로 표시한다.
- NOT: 그대로 부정(否定)이다. 즉, 참과 거짓을 뒤집는다. C언어의 영향을 받은 프로그래밍 언어에서는 일반적으로 !를 부정 연산자로 사용하며, 그 외에 ~A도 많은 프로그래밍 언어에서 사용되며, 필기나 서적 등에서는 A' 또는 A 위에 ㅡ를 그려넣은 A 기호가 주로 쓰인다. 불 보수(Boolean Complement)로도 불린다. 이 연산을 하는 회로는 따로 보수기(inverter)라는 이름으로 불린다.
- NAND: Not AND. 논리곱의 결과값을 부정한 것이다. 즉, 두 명제가 모두 참이면 거짓값을 돌려주고 그 외에는 참값을 돌려준다. 참고로 NAND만을 통해 다른 논리 연산식을 모조리 구현할 수 있기 때문에 현재 사용되는 플래시 메모리들은 대부분이 NAND 회로로 구성되어 있다.
|X|Y|F|
|---|---|---|
|0|0|1|
|0|1|1|
|1|0|1|
|1|1|0|

- NOR: Not OR. 논리합의 결과값을 부정한 것이다. 즉, 두 명제가 모두 거짓이면 참값을 돌려주고 그 외에는 거짓값을 돌려준다. NAND와 마찬가지로 NOR만으로 다른 논리 연산식을 모조리 구현할수 있기에 초기 플래시 메모리들은 대부분이 NOR 회로로 구성하였다. 근데 NAND 회로가 값이 싸다보니 이쪽은 자연스럽게 도태되었다.
- XOR: 두 명제 중 정확히 하나만 참이어야, 혹은 두 명제의 참거짓 여부가 다를 때 참값을 돌려준다. A'B+AB'와 동치이다. 논리학에서는 기호 ⊻를 사용하지만, 공학에서는 ⊕를 사용한다.

C언어의 영향을 받은 프로그래밍 언어에서는 ^를 배타적 논리합 기호로 사용한다. 다만 일반적인 경우에는 ^가 제곱으로 사용되기 때문에 처음 프로그래밍 언어를 배우는 사람들은 제곱을 하려고 ^ 기호를 사용했다가 안드로메다로 가는 경우가 있다.(…) 이 방식으로 특정 '키'를 이용해 암호화를 하면 그 '키'로 복호화가 가능해서, 암호화 기법으로도 널리 사용된다. 비교 대상의 비트가 0이든 1이든 상관 없이 같기만 하면 0을 돌려준다는 특성을 이용하여 어셈블리어 등의 언어에서 어떤 레지스터나 변수를 0으로 초기화할 때 사용되기도 한다. 이런 특성때문에 XOR을 이용해 임시변수 없이 변수를 스왑하는 기법은 메모리사용량에서야 좀 이득을 보겠지만 실제론 거의 사용되지 않는다. 스왑하는 값이 같은 주소를 참조한다면 엉망이 되기 때문.

결합법칙이 성립하므로 n항연산으로 일반화 가능하다. 이 경우 n개의 입력중 참의 개수가 홀수이면 출력이 참이 되는 연산으로 정의된다.
- XNOR: XOR는 두 개의 입력 신호가 같으면 출력 0 , XNOR은 두 개의 입력 신호가 다르면 출력 0

### 부울함수
- 부울함수는 논리 게이트들로 구성되는 논리회로도 작성 가능 따라서 부울함수의 단순화(간소화)가 필수
### 부울함수의 간소화 방법
1. 대수적인 방법
2. 도표를 이용한 방법
3. 테이블을 이용한 방법
## 드모르간 법칙
- (A·B)'=A'+B'
- (A+B)'=A'·B'

- 식을 깔끔하게 정리할 때 가장 많이 사용되는데다가 NAND 연산, NOR 연산과 밀접한 연관이 있는 만큼 불 대수에서 상당히 중요하게 다뤄지는 성질이다. 오죽하면 대부분 교재에서 이 법칙 하나만 불 대수 파트에서 분리해서 따로 가르칠 정도.

- 사실 머리를 좀 굴려보면 AND와 OR은 같은 구조의 함수지만(항등원끼리 연산하면 항등원, 나머지 경우는 항등원이 아닌 것) AND는 항등원이 1(=0')이고 OR은 항등원이 0(=1')일 뿐이라는 걸 알 수 있는데, 다시 말해 NOT은 ({0 , 1}, AND)에서 ({0, 1}, OR)로 가는 Isomorphism이다. 이중 부정규칙을 이용하면 동시에 NOT은 ({0 , 1}, OR)에서 ({0, 1}, AND)로 가는 Isomorphism이므로 결론적으로 NOT은 ({0 , 1}, AND, OR)에서 ({0, 1}, OR, AND)로 가는(연산이 서로 바뀌었다) Isomorphism이다.

이걸 이용해 드모르간 법칙을 쉽게 증명할 수 있을 뿐만 아니라 성질 항목에 나와있는 한쌍의 공식이 서로를 유도할 수 있다는 걸 쉽게 보일 수 있다.

정리: AND와 OR를 서로 바꾸고, 각 변수의 보수를 취함