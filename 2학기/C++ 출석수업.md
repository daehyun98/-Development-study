#  C++ 출석수업

## c++ 프로그래밍 첫걸음
- 컴파일러 번역
- #include <iostream> //선행처리기 지시어

### 선행처리기 지시어
- c++ 프로그램을 컴파일하기 전에 소스 프로그램을 가공하여 컴파일러가 실제로 번역할 소스 프로그램을 만드는 것
- 선행처리기 지시어로 처리를 지시함
  - 선행처리기 지시어는 '#'로 시작함
  - 선행처리기 지시어 문장은 한 행에 한 개의 문장을 작성함
- 대표적인 선행처리
  - 헤더파일 삽입: #include
  - 매크로 선언 및 해제: #define, #undef
  - 조건부 컴파일: #if

### 입출력 스트림
- std::cout 객체
  - 표준 출력 스트림 객체
  - 데이터를 문자열로 변환하여 출력함
  - 출력 연산자(삽입 연산자):<<

- std::cin 객체
  - 표준 입력 스트림 객체
  - 문자열을 입력 변수의 자료형의 값으로 변환하여 입력
  - 입력 연산자(추출 연산자):>>

### 명칭공간
- 명칭공간: 특정한 명칭들이 인식되는 프로그램의 부분
- 명칭공간 외부에서는 소속 명칭공간을 지정하여 사용
- ::a는 전역변수
- a는 지역변수
- 'using'을 이용한 명칭공간 사용
  - 특정 명칭공간이나 명칭공간 내의 특정 이름을 자주 사용하는 경우 명칭공간 지정을 간소화
  - using namespace std;
- return 0;은 실행시킨곳으로 감 이상 없게 끝났다

### C++와 객체지향 프로그래밍
- 객체(object)(cout도 객체)
  - 소프트웨어 시스템 안의 어떠한 대상을 표현한 것으로
    - 정해진 처리를 수행할 수 있음-> 행위,메소드,멤버함수
    - 처리 과정에 따라 내부 상태가 변화할 수 있음-> 속성,데이터 멤버
    - 다른 객체와 상호작용 할 수 있음->메시지 전달(멤버함수 호출)
- 클래스(class)
  - 객체의 설계도
  - 객체가 포함할 데이터 멤버의 선언과 멤버함수의 정의를 포함함


## 변수와 배열
- 변수란
  - 프로그램이 실행되는 동안 기억하고 있어야 하는 값들을 저장하는 메모리 영역
  - 변수에는 자료형과 이름이 지정되어야 함
  - 모든 변수는 사용하기 전에 미리 선언해야 함

- 변수의 초기화
  - 형식1: int total=0;
  - 형식2: int total(0);
    - int x(131070.5); // x <-131070: 오차 발생 int는 소수점 못가짐(int 4바이트, short 2바이트)
    - short y(x);  // y <-2: 오버플로 발생
  - 형식3: int total{0}; 
    - short a{total}; // 오류: 축소 변환 int 32bit short 16bit 작아서 안돼
    - float b{totla}; // 오류: 축소 변환

- 자료형 추론(c++ 11부터 가능)
  - 변수르 초기화할 때 초기화하는 값의 자료형으로 변수의 자료형을 추론
  - auto i(10); //int i(10);과 동일함 //7장 이후 템플릿때문에 씀
  - const 한정어
    - 변수의 값을 수정할 수 없게 함
    - 초기화를 통해서만 값을 정할 수 있음
      - const double PI {3.14159}; // 원주율 정의

- 배열
  - 동일한 자료형의 값을 여러 개 저장할 수 있는 연속적으로 할당된 공간을 묶어 하나의 이름을 갖는 변수로 만든 것
  - 각각의 원소는 0번부터 시작하여 차례로 부여된 번호(첨자,인덱스)를 이용하여 액세스 함
  - 배열의 차원: 배열의 첨자 개수
  - float fArray[4]; //0,1,2,3 1차원 배열의 선언
  
- 2차원 배열
  - 1차원 배열이 원소인 배열
  - int Arr2D[4][3]; //앞에[4]는 열이 된다 [3]은 행
  - 행 우선 순서(row-major-order)

- 배열의 초기화
  - int a[5] = {1,2,3,4,5}; // '='는 생략할 수 있음
  - int b[5] = {1,2,3}; // b[3],b[4]는 0으로 초기화됨
  - int b[5] = {0}
  - int c[] = {1,2,3,4,5} // 배열의 크기는 5임
  - int d[2][4] = {{1,2,3,4},{5,6,7,8}} //2차원 배열의 초기화
  - int d[2][4] = {1,2,3,4,5,6,7,8}; //1,2,3,4는 0번 5,6,7,8은 1번

- int main()
{
    int data[10] = {10,23,5,9,22,48,12,10,55,31};
    int max = data[0]; // data 0번 값을 max로 가정함

    cout << "데이터 : " << data[0]; // 0번 데이터 출력
    for ()
}
int data[10] = { 10, 23, 5, 9, 22, 48, 12, 10, 55, 31 };
    int  max=data[0];  // data의 첫 번째 데이터를 max로 가정함

    cout << "데이터 : " << max;  // 0번 데이터 출력
    for (int i = 1; i<10; i++) {    // 나머지 9개의 데이터 비교
        cout << "  " <<  data[i];     // i번 데이터 출력
        if (max < data[i])    // i번 데이터가 max보다 크면 비교
            max = data[i];     // max를 i번 데이터로 바꿈
    }
    cout << endl << endl;
    cout << "배열의 최댓값 : " << max << endl;

## 포인터와 참조
- 포인터
  - 다른 변수, 구조체, 객체 등 값이 저장된 곳을 가리키는 변수

- 포인터 선언 형식
  -  TypeName* ptrVar;
  - TypeName: 가리킬 값의 자료형
  - ptrVar: 포인터 변수의 이름

- 포인터의 사용
  - 포인터가 유효한 대상을 가리키게 한 후 사용해야 함
  - ptrVar = &var; // ptrVar이 var을 가리키게 함
  - *ptrVar = value; // ptrVar을 이용하여 var을 액세스
  - &: 주소 계산 연산자
  - *ptrVar: 포인터 ptrVar이 가리키는 곳(대상)
  - 예) int a;
        int* iPtr = &a;
        *iPtr = 10;

#include <iostream>
using namespace std;
int main()
{
  int  a = 10, b = 100;
  int  *ptr=&a; 	 // 포인터 ptr을 선언한 후에 a의 주소를 넣는다.
  cout << "ptr이 가리키는 곳의 값 : " << *ptr<< endl;
   *ptr= 20;   // ptr이 가리키는 곳에 20을 저장
  cout << "변수 a의 값 : " << a << endl;
  ptr=&b;         // ptr이 b를 가리키게 함
  cout << "변수 b의 값 : " << *ptr << endl;
  return 0;
} // 포인터는 포인트로-> 가르킨다라고생각하시면될꺼같습니다 .!

- 동적 메모리 할당
  - 프로그램 동작 중에 기억공간의 필요성 및 소요량을 결정하여 필요한 공간을 할당하는 것
    - 기억 공간의 생성 시점: new 연산자의 실행 시험
    - 기억 공간의 소멸 시점: delete 연산자의 실행 시점
  - 포인터 변수가 할당된 기억 공간을 가리키게 함

- 메모리 할당 연산자
  - ptrVar = new TypeName;
  - ptrVar = new TypeName[n];

- 메모리 반납 연산자
  - delete ptrVar;
  - delete [] ptrVar;

- 단일 데이터 공간의 할당 및 반납
  - int* intPtr;
    intPtr = new int;
    *intPtr = 10;

    delete intPtr;
    intPtr = nullptr; //c++ 11부터 아무것도 가르키지 않는다는 표시

- 배열 데이터 공간의 할당 및 반납
  - int* intPtr;
    intPtr = new int[4];
    *intPtr = 10;
    *(intPtr+1)=20;
    intPtr[2]=30;

    delete [] intPtr;
    intPtr = nullptr;


- 배열 데이터 공간의 할당 및 반납
#include <iostream>
using namespace std;
int main()
{
    char* sPtr;
    int  maxSLen, len{0};
    cout << "단어의 최대 길이를 입력하시오 : ";
    cin >> maxSLen;
    sPtr=new char[maxSLen];  // maxSLen개의 문자를 저장할 메모리 할당
    cout << "단어를 입력하시오 : ";
    cin >> sPtr;
    for (char* p =sPtr; *p; p++ ) // p를 이용하여 sPtr의 시작부터 끝까지 반복    
         len++; // 문자 수를 카운트 
    cout << sPtr << "의 문자 수: " <<  len << endl;
     delete[] sPtr; // ㈀에서 할당한 메모리 반환
}

- 참조(reference)(rvalue는 &&두개,lvalue는 &한개)
  - 어떠한 대상을 가리키는 값(포인터와 유사함)
  - 참조 변수는 참조 대상의 별명처럼 사용할 수 있음
  - l-value 참조: 실체가 있는 대상에 대한 참조

- l-value 참조 변수의 선언 형식
  - TypeName& refVar = varName;
    - TypeName: 참조 대상의 자료형
    - refVar: 참조 변수의 이름
    - varName: 참조 대상

- const 참조
  - 참조 변수가 참조하는 대상의 값을 바꿀 수 없음
  - int x{10};
    const int& xRef = x;
    const << xRef << endl; // x의 값을 읽어 출력함
    xRef += 10; // 오류: const 참조로 값을 수정할 수 없음

- 참조가 포인터와 다른 점
  - 참조 변수를 이용하여 값을 읽거나 저장할 때 참조 대상 변수를 사용하는 형식과 동일함
  - 참조 변수는 초기화를 통해 반드시 어떤 대상을 참조해야 함
    - 초기화되지 않은 상태로 인해 무엇을 참조하고 있는지 알 수 없는 상황은 발생하지 않음
  - 참조 변수는 초기화를 통해 지정된 참조 대상을 바꿀 수 없어 참조의 유효기간 동안 하나의 대상만 참조할 수 있음


과제물:문제 8문제 풀어서 과제 제출
2~8번
모든 프로그램 cout으로 메인 함수의 처음에 학번과 이름 출력